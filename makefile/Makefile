# Modules in the project (you could 'find' these, but stating
# them explicitly allows for subdirectories like 'tmp' or 'doc'
# without upsetting the build process.
MODULES := bar baz

# Global CFLAGS. Add to them if you must, but don't remove '-MMD -I includes',
# which is used for header dependency tracking.
CFLAGS_global := -Wall -MMD -I./includes
# Global ARFLAGS.
ARFLAGS := cr
# Global LDFLAGS.
LDFLAGS_global := \
	--build-id --no-add-needed --eh-frame-hdr -m elf_i386 --hash-style=gnu \
	-dynamic-linker /lib/ld-linux.so.2 /usr/lib/crt1.o /usr/lib/crti.o \
	/usr/lib/gcc/i686-redhat-linux/4.6.3/crtbegin.o \
	-L/usr/lib/gcc/i686-redhat-linux/4.6.3 -L/usr/lib
LDFLAGS_global2 := \
	-lgcc --as-needed -lgcc_s --no-as-needed -lc -lgcc --as-needed -lgcc_s \
	--no-as-needed /usr/lib/gcc/i686-redhat-linux/4.6.3/crtend.o \
	/usr/lib/crtn.o
# C Compiler
CC := gcc

TARGETS:=
.PHONY: all clean distclean mrproper

.DEFAULT_GOAL := all

###################################################################
# What follows are several templates (think "functions"), which are
# later instantiated for each registered module ($(1) being the
# module name).
###################################################################

# Setup build environment
build_env:
	@mkdir -p bin lib

define ENV_template
$(1)/obj:
	@mkdir -p $$@
endef

# Setting a module's build rules for object files in <module>/obj.
define RULES_template
$(1)/obj/%.o: $(1)/src/%.c $(1)/obj
	$$(CC) $$(CFLAGS) $$(CFLAGS_global) $$(CFLAGS_$(1)) -c $$< -o $$@
endef

# Setting a module's build rules for executable targets.
# (Depending on its sources' object files and any libraries.)
# Also adds a module's dependency files to the global list.
define PROGRAM_template
DEPENDENCIES := $(DEPENDENCIES) $(patsubst %,$(2)/obj/%.d,$(basename $($(1)_SOURCES)))
TARGETS += bin/$(1)
bin/$(1): $(patsubst %,$(2)/obj/%.o,$(basename $($(1)_SOURCES))) $(foreach library,$($(1)_LIBRARIES),lib/$(library))
	$$(LD) $$(LDFLAGS) $$(LDFLAGS_global) $$(LDFLAGS_$(2)) $$< $$(LDFLAGS_global2) -o $$@
endef

# Setting a module's build rules for archive targets.
# (Depending on its sources' object files.)
define LIBRARY_template
DEPENDENCIES := $(DEPENDENCIES) $(patsubst %,$(2)/obj/%.d,$(basename $($(1)_SOURCES)))
TARGETS += lib/$(1).a
lib/$(1).a: $(patsubst %,$(2)/obj/%.o,$(basename $($(1)_SOURCES)))
	$$(AR) $$(ARFLAGS) $$@
	$(CC) -fPIC -shared -Wl,-whole-archive $$@ -Wl,--no-whole-archive -o lib/$(1).so
endef

# Now, instantiating the templates for each module.
$(foreach module,$(MODULES),$(eval include $(module)/build.mk))
$(foreach module,$(MODULES),$(eval $(call ENV_template,$(module))))
$(foreach module,$(MODULES),$(eval $(call RULES_template,$(module))))
$(foreach module,$(MODULES),$(eval $(foreach binary,$($(module)_PROGRAM),$(call PROGRAM_template,$(binary),$(module)))))
$(foreach module,$(MODULES),$(eval $(foreach library,$($(module)_LIBRARY),$(call LIBRARY_template,$(library),$(module)))))

# Include the dependency files (generated by GCC's -MMD option)
-include $(sort $(DEPENDENCIES))

all: build_env $(TARGETS)
#	@echo TARGETS: $(TARGETS)

clean:
	$(RM) $(foreach mod,$(MODULES),$(mod)/obj/*.o,$(mod)/obj/*.d) bin/* lib/*

distclean: clean
	$(RM) -r $(foreach mod,$(MODULES),$(mod)/obj) bin lib

mrproper: clean
	$(RM) $(foreach mod,$(MODULES),$(mod)/obj/*.d) includes/* bin/* lib/*
